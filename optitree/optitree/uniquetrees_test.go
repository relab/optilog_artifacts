package main

import (
	"fmt"
	"os"
	"slices"
	"testing"

	"github.com/google/go-cmp/cmp"
)

func TestLoadLatencies(t *testing.T) {
	latencies, err := loadLatencies(awsLatencyFile, "random")
	if err != nil {
		t.Fatal(err)
	}
	if len(latencies) != len(cities) {
		t.Errorf("Expected %d latencies, got %d", len(cities), len(latencies))
	}
	if len(latencies[0]) != len(cities) {
		t.Errorf("Expected %d latencies, got %d", len(cities), len(latencies[0]))
	}
	for i, row := range latencies {
		t.Logf("%3d: %15s: %v ... %v", i, cityName(i), row[:5], row[len(row)-5:])
	}

	latencies, err = loadLatencies(wonderproxyLatencyFile, "random")
	if err != nil {
		t.Fatal(err)
	}
	if len(latencies) != len(cities) {
		t.Errorf("Expected %d latencies, got %d", len(cities), len(latencies))
	}
	if len(latencies[0]) != len(cities) {
		t.Errorf("Expected %d latencies, got %d", len(cities), len(latencies[0]))
	}
	for i, row := range latencies {
		t.Logf("%3d: %15s: %v ... %v", i, cityName(i), row[:5], row[len(row)-5:])
	}
}

// Excerpt from wonderproxy.csv:
//            Melbourne, Toronto, Prague , Paris,   Tokyo,   Amsterdam,
// Melbourne, 0.0,       218.592, 242.737, 279.703, 143.378,  274.962,
// Toronto  , 218.592,   0.0,     109.877, 92.279,  178.253,  94.375,
// Prague   , 242.737,   109.877, 0.0,     23.061,  269.007,  20.941,
// Paris    , 279.703,   92.279,  23.061,  0.0,     234.898,  9.92,
// Tokyo    , 143.378,   178.253, 269.007, 234.898, 0.0,      239.909,
// Amsterdam, 274.962,   94.375,  20.941,  9.92,    239.909,  0.0,

func TestCitiesLatencies(t *testing.T) {
	const wantCities = 4
	latencies, err := loadLatencies(wonderproxyLatencyFile, "Melbourne,Prague,Paris,Amsterdam")
	if err != nil {
		t.Fatal(err)
	}
	if len(latencies) != wantCities {
		t.Errorf("Expected %d latencies, got %d: %v", wantCities, len(latencies), latencies)
	}
	if len(latencies[0]) != wantCities {
		t.Errorf("Expected %d latencies, got %d: %v", wantCities, len(latencies[0]), latencies[0])
	}
	if len(cities) != wantCities {
		t.Errorf("Expected %d cities, got %d: %v", wantCities, len(cities), cities)
	}

	// Map of latencies between cities (in Âµs); generated by ChatGPT-4o based on the above table.
	wantLatency := map[string]map[string]Latency{
		"Melbourne": {
			"Melbourne": 0,
			"Toronto":   109296,
			"Prague":    121369,
			"Paris":     139852,
			"Tokyo":     71689,
			"Amsterdam": 137481,
		},
		"Toronto": {
			"Melbourne": 109296,
			"Toronto":   0,
			"Prague":    54939,
			"Paris":     46140,
			"Tokyo":     89127,
			"Amsterdam": 47188,
		},
		"Prague": {
			"Melbourne": 121369,
			"Toronto":   54939,
			"Prague":    0,
			"Paris":     11531,
			"Tokyo":     134504,
			"Amsterdam": 10471,
		},
		"Paris": {
			"Melbourne": 139852,
			"Toronto":   46140,
			"Prague":    11531,
			"Paris":     0,
			"Tokyo":     117449,
			"Amsterdam": 4960,
		},
		"Tokyo": {
			"Melbourne": 71689,
			"Toronto":   89127,
			"Prague":    134504,
			"Paris":     117449,
			"Tokyo":     0,
			"Amsterdam": 119955,
		},
		"Amsterdam": {
			"Melbourne": 137481,
			"Toronto":   47188,
			"Prague":    10471,
			"Paris":     4960,
			"Tokyo":     119955,
			"Amsterdam": 0,
		},
	}

	for i := range len(latencies) {
		t.Logf("%d: %s: %v", i, cityName(i), latencies[i])
	}

	for from := range len(latencies) {
		for to := range len(latencies) {
			fCity, tCity := cityName(from), cityName(to)
			name := fmt.Sprintf("from=%d=%s/to=%d=%s", from, fCity, to, tCity)
			t.Run(name, func(t *testing.T) {
				got := latencies.pathLatency(from, to)
				want := wantLatency[fCity][tCity]
				if got != want {
					t.Errorf("latencies[%d=%s][%d=%s] = %d, want %d", from, fCity, to, tCity, got, want)
				}
				gotReverse := latencies.pathLatency(to, from)
				wantReverse := wantLatency[tCity][fCity]
				if gotReverse != wantReverse {
					t.Errorf("latencies[%d=%s][%d=%s] = %d, want %d", to, tCity, from, fCity, gotReverse, wantReverse)
				}
			})
		}
	}
}

func TestNumTrees(t *testing.T) {
	tree := []int{0, 1, 2, 3, 5, 7, 8, 9, 12, 15, 16, 17, 19}
	var want int64 = 4804800
	got := NumTrees(len(tree), 3)
	if got != want {
		t.Errorf("NumTrees(%d, %d) = %d, want %d", len(tree), 3, got, want)
	}
}

func TestNumTreesBig(t *testing.T) {
	// not a real test, just to see how big the numbers get
	for bf := range 11 {
		t.Run(fmt.Sprintf("bf=%d", bf), func(t *testing.T) {
			sz := TreeSize(bf)
			t.Logf("NumTreesInt64 (%d, %d) = %d", sz, bf, NumTrees(sz, bf))
			t.Logf("NumTreesBigInt(%d, %d) = %d", sz, bf, NumTrees2(sz, bf))
		})
	}
}

func TestPrintTree(t *testing.T) {
	if os.Getenv("PRINT") == "" {
		t.Skip("Skipping test; set PRINT=1 to enable")
	}
	latencies, err := loadLatencies(awsLatencyFile, "random")
	if err != nil {
		t.Fatal(err)
	}
	bf := 3
	tree := []int{0, 1, 2, 3, 5, 7, 8, 9, 12, 15, 16, 17, 19}
	latencies.Print(tree, bf)
	tree = []int{0, 1, 2, 3, 5, 7, 8, 9, 12, 15, 16, 17, 19}
	latencies.Print(tree, bf)
	bf = 4
	tree = []int{17, 0, 2, 8, 9, 5, 6, 12, 15, 1, 3, 4, 7, 16, 18, 19, 20, 10, 11, 13, 14}
	latencies.Print(tree, bf)
	tree = []int{3, 0, 1, 2, 4, 5, 6, 13, 14, 9, 10, 11, 15, 7, 8, 16, 18, 17, 12, 19, 20}
	latencies.Print(tree, bf)

	lat := latencies.treeLatency(tree[0], bf, tree[1:])
	t.Logf("Total latency: %d", lat)
}

func TestTreeLatency(t *testing.T) {
	latencies := NewRand(14)
	root := 1
	branchFactor := 3
	tree := []int{2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}

	totalLatency := latencies.treeLatency(root, branchFactor, tree)
	t.Logf("Total latency: %d", totalLatency)
}

func TestGenerateTree(t *testing.T) {
	tests := []struct {
		want []int
		root int
	}{
		{root: 0, want: []int{1}},
		{root: 0, want: []int{1, 2}},
		{root: 0, want: []int{1, 2, 3}},
		{root: 0, want: []int{1, 2, 3, 4}},
		{root: 0, want: []int{1, 2, 3, 4, 5}},
		{root: 0, want: []int{1, 2, 3, 4, 5, 6}},
		{root: 0, want: []int{1, 2, 3, 4, 5, 6, 7}},
		{root: 1, want: []int{0, 2, 3, 4, 5, 6, 7}},
		{root: 2, want: []int{0, 1, 3, 4, 5, 6, 7}},
		{root: 3, want: []int{0, 1, 2, 4, 5, 6, 7}},
		{root: 4, want: []int{0, 1, 2, 3, 5, 6, 7}},
		{root: 5, want: []int{0, 1, 2, 3, 4, 6, 7}},
		{root: 6, want: []int{0, 1, 2, 3, 4, 5, 7}},
		{root: 7, want: []int{0, 1, 2, 3, 4, 5, 6}},
		{root: 0, want: []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}},
		{root: 1, want: []int{0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}},
		{root: 2, want: []int{0, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}},
		{root: 3, want: []int{0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12}},
		{root: 4, want: []int{0, 1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12}},
		{root: 5, want: []int{0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12}},
		{root: 6, want: []int{0, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12}},
		{root: 7, want: []int{0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12}},
		{root: 8, want: []int{0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12}},
		{root: 9, want: []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12}},
		{root: 10, want: []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12}},
		{root: 11, want: []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12}},
		{root: 12, want: []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}},
	}
	for _, tt := range tests {
		t.Run(fmt.Sprintf("size=%d", len(tt.want)+1), func(t *testing.T) {
			got := generateBaseTree(len(tt.want)+1, tt.root)
			if diff := cmp.Diff(tt.want, got); diff != "" {
				t.Errorf("generateTree() mismatch (-want +got):\n%s", diff)
			}
		})
	}
}

func isTreeSorted(bf int, tree []int) bool {
	for i := 0; i < len(tree); i += bf {
		if !slices.IsSorted(tree[i:min(i+bf, len(tree))]) {
			return false
		}
	}
	return true
}

func TestUniqueTrees(t *testing.T) {
	tests := []struct {
		bf int
	}{
		{bf: 2}, // 630 trees
		{bf: 3}, // 4804800 trees
		// {bf: 4}, // 6416344935000 trees (will take forever)
	}
	for _, tt := range tests {
		size := TreeSize(tt.bf)
		t.Run(fmt.Sprintf("size=%v/bf=%d/trees=%d", size, tt.bf, NumTrees(size, tt.bf)), func(t *testing.T) {
			baseTree := generateBaseTree(size, 0)
			uniqueTreesPerRoot := 0
			// Count the number of unique trees for a single root
			UniqueTrees(baseTree, tt.bf, func(tree []int) {
				uniqueTreesPerRoot++
				if len(tree) != len(baseTree) {
					t.Errorf("len(tree) = %d, want=%d", len(tree), len(baseTree))
				}
				if !isTreeSorted(tt.bf, tree) {
					t.Errorf("The generated tree %v is not sorted", tree)
				}
			})
			wantUniqueTrees := NumTrees(size, tt.bf)
			gotUniqueTrees := int64(uniqueTreesPerRoot * size)
			if gotUniqueTrees != wantUniqueTrees {
				t.Errorf("Number of unique trees = %d, want=%d", gotUniqueTrees, wantUniqueTrees)
			}
		})
	}
}

// Run with: go test -v -run ^$ -bench BenchmarkUniqueTrees -benchmem -timeout=0 -count=5
//
// On my MacPro from 2013 I get 33561925 trees/second for bf=3. Using that number to estimate
// the time for bf=4: 6416344935000/33561925 seconds = 191179 seconds ~ 53 hours.
// However, since the time it takes to evaluate a single bf=4 tree is higher than for bf=3,
// the actual time will be much higher.
func BenchmarkUniqueTrees(b *testing.B) {
	tests := []struct {
		fn   func(tree []int, branchFactor int, eval func([]int))
		name string
		bf   int
	}{
		{name: "UniqueTrees", fn: UniqueTrees, bf: 2},
		{name: "UniqueTreesStruct", fn: UniqueTreesStruct, bf: 2},
		{name: "UniqueTrees", fn: UniqueTrees, bf: 3},
		{name: "UniqueTreesStruct", fn: UniqueTreesStruct, bf: 3},
	}
	for _, tt := range tests {
		size := TreeSize(tt.bf)
		trees := NumTrees(size, tt.bf)
		b.Run(fmt.Sprintf("name=%s/size=%v/bf=%d/trees=%d", tt.name, size, tt.bf, trees), func(b *testing.B) {
			tree := generateBaseTree(size, 0)
			b.ResetTimer()
			b.StartTimer()
			for range b.N {
				cnt := 0
				tt.fn(tree, tt.bf, func(tree []int) {
					cnt++
				})
			}
			b.StopTimer()
			// Report the number of trees per second over all iterations
			treesPerSecond := float64(int64(b.N)*trees) / b.Elapsed().Seconds()
			b.ReportMetric(treesPerSecond, "trees/sec")
		})
	}
}
